#!/usr/bin/env python3.4
"""
A sample Ivy monitor written in python and Qt ... and in a couple of hours
usage: python-3.4 ivymon.py

prerequisites: py34-pyqt5, ivy for python3
Copyright (c) 2016 Yannick Jestin <yannick.jestin@gmail.com>
"""
import logging
import argparse
import sys
import signal
import platform
from PyQt5 import QtCore, QtWidgets
from datetime import datetime
from ivy import ivy
from ui_main_new import Ui_Main
from ui_agent import Ui_Agent
from ui_about import Ui_About

DEFAULTBUS = {'Darwin': "224.255.255.255:2010",
              'Linux': "127.255.255.255:2010"}


class Agent():
    """a helper class holding the ivy agent, the list item, and a handle to a
    Qt Window
    """

    def __init__(self, agent):
        """ the constructor
        cannot use Qt logic so far, as it's called from an Ivy thread
        """
        self.agent = agent
        self.name = agent.agent_name
        self.item = QtWidgets.QListWidgetItem(self.name)
        self.window = None

    def doshow(self):
        """here I can build the windows"""
        # I cannot be built at object __init__
        # as it is triggered by an Ivy thread and not a Qt signal
        # thus doshow must be called within Qt
        self.window = QtWidgets.QWidget()
        self.ui = Ui_Agent()
        self.ui.setupUi(self.window)
        self.ui.nameLabel.setText(self.name)
        self.ui.ipLabel.setText(str(self.agent.ip))
        self.ui.portLabel.setText(str(self.agent.port))
        self.ui.addressLabel.setText(self.agent.fqdn)
        self.update_regex()
        self.window.show()

    def update_regex(self):
        """called each time a regex is added or deleted, starts from zero"""
        if self.window is None:
            return
        self.ui.regexpList.clear()
        for re in self.agent.regexps.values():
            self.ui.regexpList.addItem(QtWidgets.QListWidgetItem(re[0]))


class IvyMonView(QtWidgets.QMainWindow):
    """
    the graphical view of IvyMon
    it's based on ui_main.py generated by pyuic5
    """

    new_message = QtCore.pyqtSignal(int, str)

    def __init__(self, bus, busaddr, name):
        """a builder"""
        QtWidgets.QFrame.__init__(self)
        self.bus = bus
        self.agents = []
        self.about_window = None
        self.ui = Ui_Main()
        self.ui.setupUi(self)
        self.ui.busLabel.setText(busaddr)
        self.ui.nameLabel.setText(name)
        self.ui.removeButton.clicked.connect(self.unbind)
        self.ui.addButton.clicked.connect(self.bind)
        self.ui.newBinding.activated.connect(self.bind)
        self.ui.killButton.clicked.connect(self.kill)
        self.ui.inspectButton.clicked.connect(self.inspect)
        self.ui.sendButton.clicked.connect(self.send)
        self.ui.msg.activated.connect(self.send)
        self.new_message.connect(self.slot_message)
        self.ui.actionCredits.triggered.connect(self.about)
        self.ui.actionQuit.triggered.connect(self.bus.sigstop)
        self.ui.actionSending.toggled.connect(self.ui.idDock.setVisible)
        self.ui.actionBindings.toggled.connect(self.ui.bindDock.setVisible)
        self.ui.agentList.itemDoubleClicked.connect(self.inspect)
        self.show()

    def about(self):
        if self.about_window is not None:
            self.about_window.show()
            return
        self.about_window = QtWidgets.QDialog()
        ui = Ui_About()
        ui.setupUi(self.about_window)
        self.about_window.show()

    def add_binding(self, regexp):
        self.ui.bindList.addItem(QtWidgets.QListWidgetItem(regexp))

    def add_agent(self, agent):
        # adds an agent in the list by ivy agent
        a = Agent(agent)
        self.agents.append(a)
        self.ui.agentList.addItem(a.item)

    def remove_agent(self, agent):
        # removes an agent from the list by ivy agent
        for a in [x for x in self.agents if x.agent is agent]:
            self.ui.agentList.takeItem(self.ui.agentList.row(a.item))
            self.add_message(1, [a.item.text() + " left"])
        self.agents = [x for x in self.agents if x.agent is not agent]

    def inspect(self):
        for item in self.ui.agentList.selectedItems():
            for a in [x for x in self.agents if x.item is item]:
                a.doshow()

    def kill(self):
        for item in self.ui.agentList.selectedItems():
            self.add_message(1, ["killed " + item.text()])
            self.ui.agentList.takeItem(self.ui.agentList.row(item))
            for a in [x for x in self.agents if x.item is item]:
                a.agent.send_die_message()
            self.agents = [x for x in self.agents if x.item is not item]

    def unbind(self):
        for item in self.ui.bindList.selectedItems():
            re = item.text()
            self.bus.unbind_msg(self.bus.bound[re])
            self.ui.bindList.takeItem(self.ui.bindList.row(item))
            self.add_message(1, ["unbound to " + re])

    def bind(self):
        new = self.ui.newBinding.currentText()
        if len(new) is 0:
            return
        self.bus.add_binding(new)
        self.add_message(1, ["bound to " + new])

    def add_message(self, i, args):
        self.new_message.emit(i ,datetime.now().strftime("%H:%M:%S") +
                              ' - ' + ":".join(args))

    def slot_message(self, i, msg):
        if i is 0:
            scroll = self.ui.messages.verticalScrollBar()
            pos = scroll.value()
            self.ui.messages.append(msg)
            if self.ui.autoScroll.isChecked():
                scroll.setValue(scroll.maximum())
            else:
                scroll.setValue(pos)
        elif i is 1:
            self.ui.events.append(msg)
            scroll = self.ui.events.verticalScrollBar()
            scroll.setValue(scroll.maximum())

    def my_regexp_change(self, agent, event, num_id, regexp):
        self.add_message(1, ["regexp change ", agent.agent_name, str(event),
                          str(num_id), regexp])
        for a in [x for x in self.agents if x.agent is agent]:
            a.update_regex()

    def send(self):
        text = self.ui.msg.currentText()
        self.add_message(1, ["sending ", text])
        self.bus.send_msg(text)


class IvyMon(ivy.IvyServer):
    """une classe pour visualier le trafic ivy sur un bus donné"""

    def __init__(self, bus):
        """Initialisation du rejeu sur un bus Ivy"""
        self.bus = bus
        self.name = 'IvyMon'
        self.bound = {}  # key=regexp, value=id
        # initialise la vue
        self.view = IvyMonView(self, self.bus, self.name)
        # initialise le bus
        ivy.IvyServer.__init__(self, self.name, 'IvyMon READY',
                               self.my_app_callback,
                               self.sigstop)
        ivy.ivylogger.setLevel(logging.ERROR)
        self.add_binding('(.*)')
        self.bind_regexp_change(self.view.my_regexp_change)
        self.start(self.bus)

    def sigstop(self, *args):
        """gestionnaire de signaux :si on interromp le programme par ^C"""
        # j'ai reçu un SIGSTOP, je quitte le bus
        if self.isAlive:
            self.stop()
        # puis je quitte Qt Main Loop
        QtCore.QCoreApplication.instance().quit()

    def add_binding(self, regexp):
        self.bound[regexp] = self.bind_msg(self.my_receive, regexp)
        self.view.add_binding(regexp)

    def my_receive(self, agent, *args):
        self.view.add_message(0, args)

    def my_app_callback(self, agent, connexion):
        if connexion == ivy.IvyApplicationConnected:
            self.view.add_agent(agent)
        else:
            self.view.remove_agent(agent)


def args(argv):
    """analyse les arguments en ligne de commande"""
    defaultbus = DEFAULTBUS.get(platform.system(), "127.255.255.255:2010")
    parser = argparse.ArgumentParser(description='rejeu de données paparazzi')
    parser.add_argument('-b', type=str, help='Ivy bus domain')
    args = parser.parse_args()
    bus = args.b if args.b else defaultbus
    return bus

if __name__ == "__main__":
    """programme principal"""
    app = QtWidgets.QApplication(sys.argv)
    bus = args(sys.argv)
    mon = IvyMon(bus)
    signal.signal(signal.SIGINT, mon.sigstop)
    res = app.exec_()
    if mon.isAlive():
        mon.stop()
    sys.exit(res)
